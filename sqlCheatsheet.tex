\documentclass{sciposter}
\usepackage[dvipsnames,usenames,svgnames,table]{xcolor} 
\usepackage{lipsum}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{gensymb}
\usepackage[utf8]{inputenc}
\usepackage{empheq}
% have a table that spans two pages
\usepackage{xtab,booktabs}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{xtab}

\usepackage{graphicx,url}
\usepackage{palatino}

\geometry{
 landscape,
 a1paper,
 left=5mm,
 right=50mm,
 top=5mm,
 bottom=50mm,
 }




\providecommand{\tightlist}{%
	\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

%BEGIN LISTINGDEF

\usepackage{listings}
   
\usepackage{inconsolata}

\definecolor{background}{HTML}{fcfeff}
\definecolor{comment}{HTML}{b2979b}
\definecolor{keywords}{HTML}{255957}
\definecolor{basicStyle}{HTML}{6C7680}
\definecolor{variable}{HTML}{001080}
\definecolor{string}{HTML}{c18100}
\definecolor{numbers}{HTML}{3f334d}

\lstdefinestyle{lectureNotesListing}{
	xleftmargin=0.5em, % 2.8 with line numbers
	breaklines=true,
	frame=single,
	framesep=0.6mm,
	frameround=ffff,
	framexleftmargin=0.4em, % 2.4 with line numbers | 0.4 without them
	tabsize=4, %width of tabs
	aboveskip=0.5em,
	classoffset=0,
	sensitive=true,
	% Colors
	backgroundcolor=\color{background},
	basicstyle=\color{basicStyle}\small\ttfamily,
	keywordstyle=\color{keywords},
	commentstyle=\color{comment},
	stringstyle=\color{string},
	numberstyle=\color{numbers},
	identifierstyle=\color{variable},
	showstringspaces=true
}
\lstset{style=lectureNotesListing}


%END LISTINGDEF

\usepackage{todonotes}
\newcommand{\TODO}[1]{\todo[inline]{\Large TODO:  #1}}
\newcommand*\widefbox[1]{\fbox{\hspace{2em}#1\hspace{2em}}}



\renewcommand{\t}[1]{\texttt{#1}}




%BEGIN TITLE
\title{\huge{SQL}}

% if you want to set an author replace the next line with \author{your name here}
\author{\vspace{-1cm}}

\renewcommand{\familydefault}{\rmdefault}

\begin{document}

\maketitle

\begin{multicols}{3}

This short paper summarizes important SQL concepts. All the content and examples are from \textit{Database Systems: The Complete Book} by Garcia-Molina, Ullman and Widom as well as ETH's lecture slides by Prof.\ Ce Zhang.




\section*{Simple SQL Queries}

A basic SQL query has the form \t{SELECT <attr> FROM <rels> WHERE <cond>} where 
\begin{itemize}
	\item \t{<attr>} are the attributes of the relation we would like to have
	\item \t{<rels>} are the tuples (the relation) we are selecting from
	\item \t{<cond>} filters the tuples in the relation only keeping the ones satisfying the condition
\end{itemize}

A basic query might look as follows:

\begin{lstlisting}[language=SQL]
SELECT title, year, producer FROM
movies WHERE id = 10;
\end{lstlisting}

Conditions are specified with \t{<attr-name> = <value>} and can be chained together using \t{AND, OR, NOT, ()}

\subsection*{String Comparison}

Strings are lexicographically ordered in SQL and can be compared to each other.

We can also use wildcards:
\begin{itemize}
	\item \t{\_} matches exactly one character: \t{WHERE title LIKE 'Ice \_\_\_'} would match any movie that has three characters following the space. (such as Ice age or Ice tea).
	\item\t{\%} matches 0 or more characters: \t{WHERE title LIKE '\%sor\%s'} matches or, order, etc.
\end{itemize}


\subsection*{Dates and Times}
Are prefixed with a keyword \t{DATE, TIMESTAMP, TIME}.
\begin{itemize}
	\item \t{DATE '1999-12-01'} is the first of December of 1999
	\item \t{TIME '15:00:03.25} is 3 and a quarter minutes past three PM.
	\item \t{TIMESTAMP '1966-03-22 13:00:12-1:00'}, notice the \t{-1:00} meaning one hour behind GTM.
\end{itemize}

To extract information you can use \t{SELECT EXTRACT(<selector> FROM <date/time>)} for example \t{SELECT EXTRACT(MONTH FROM '2000-00-12')}


\subsection*{NULL Values and Unknowns}

When a value is not specified in the table it defaults to \t{NULL}.
When we make comparisons and have a \t{NULL} involved the truth value will become an \t{UNKNOWN}. On logical operators in behaves similarly to a \t{FALSE}, though it is not \t{FALSE}. Arithmetic expressions on \t{NULL} result in \t{NULL}.

The database only returns tuples where the \t{WHERE} clause evaluates to true. Hence if we have an \t{UNKNOWN} it will not be returned.


\section*{Full Relation Operations}

\TODO{...}


\subsection*{Recursive Query}
The basic structure is 
\begin{lstlisting}[language=SQL]
WITH RECURSIVE recRel AS(
non_recursive-term
UNION [ALL]
recursive-term
) SELECT * FROM recRel;
\end{lstlisting}
The database executes the \t{recursive-term} as long as the resulting set keeps changing.
\begin{lstlisting}[language=SQL]
WITH RECURSIVE anchestor AS (
	SELECT * FROM people
UNION
	SELECT * from people as p
	WHERE p.father = anchestor.id OR p.mother = anchestor.id
)
SELECT * from anchestor;
\end{lstlisting}

\subsection*{Aggregation Operators}

SQL has five aggregation operators: \texttt{SUM, AVG, MIN, MAX, COUNT}. All except the \t{COUNT} are applied to scalar valued columns. The only excpetion being \t{COUNT(*)} which counts the tuples in the relation constructed from the \t{FROM} and \t{WHERE} clause.

\begin{lstlisting}[language=SQL]
SELECT AVG(netWorth), COUNT(*) 
FROM MovieExec;
\end{lstlisting}


\subsection*{Grouping}
The \t{GROUP BY} clause follows the \t{WHERE} clause and lists arguments that, if two tuples match on these arguments, will place them in the same group. The aggregation operators in the \t{SELECT} are applied on a per group basis. Only attributes mentioned in the \t{GROUP BY} clause may appear in the \t{SELECT} clause.

\begin{lstlisting}[language=SQL]
SELECT studioName, SUM(length)
FROM Movies
GROUP BY studioName;
\end{lstlisting}

\subsection*{Grouping, Aggregation and Nulls}
\begin{itemize}
	\item The value NULL is ignored in aggregation. \t{COUNT(*)} though counts number of tuples, but \t{COUNT(A)} counts number of attributes \t{A} and skips NULLS.
	\item NULL is treated as an ordinary value when forming groups.
	\item Aggregations over empty bag are NULL, except \t{COUNT(*)} being 0.
\end{itemize}


\subsection*{Having}

Assume we would like to filter the groups we have aggregated: We can do this by adding a \t{HAVING} clause. e.g. we only want the names of sellers which have no sale below or equals 500:

\begin{lstlisting}[language=SQL]
SELECT COUNT(*), Name
FROM SellerSale
GROUP BY Name
HAVING MIN(Sale) > 500;
\end{lstlisting}


\section*{Data Modifications}

\subsection*{Insertions}

Basic syntax:

\texttt{
INSERT INTO $R$($A_1,\ldots,A_n$) VALUES ($v_1,\ldots v_n$);
}

if they are already in standard order we can also write:

\texttt{
	INSERT INTO $R$ VALUES ($v_1,\ldots v_n$);
}

or insert programmatically:

\begin{lstlisting}[language=SQL]
INSERT INTO Relation1
	SELECT ....
\end{lstlisting}

We note that values are only inserted after the query has been fully computed preventing interference.

\subsection*{Deletions}
We cannot specify the exact tuple to be deleted, instead we must specify a set of tuples (which can contain 1 tuple) to be deleted.
\begin{lstlisting}[language=SQL]
DELETE FROM R WHERE <cond>
\end{lstlisting}

\subsection*{Updates}
Basic syntax:

\texttt{UPDATE $R$ SET <new vals> WHERE <cond>};

where the new vals are the name of the variable followed by an equals sign and the new assignment. 
\begin{lstlisting}[language=SQL]
UPDATE Professor
SET name = 'Prof. ' || name
WHERE title = 'Professor';
\end{lstlisting}
recall that the \t{||} operator concatenates strings.


\section*{Transactions}


A transaction is a set of SQL commands that get executed atomically. In PostgreSQL every statement in the shell is automatically wrapped in a transaction:

\begin{lstlisting}[language=SQL]
BEGIN;
UPDATE accounts SET balance = balance - 100.00
WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
WHERE name = 'Bob';
-- oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
WHERE name = 'Wally';
COMMIT;
\end{lstlisting}


\section*{Views}

A view is a virtual relation which is built on a query run on a table. 
\begin{lstlisting}[language=SQL]
CREATE VIEW <viewName> as <viewDefinition>;
\end{lstlisting}
where \t{viewDefinition} is a SQL query.

we can delete a view with \t{DROP VIEW <viewName>;}

\subsection*{Updating Views}

We can only update views satisfying some constraints:
\begin{itemize}
	\item only one base relation involved
	\item the view involves the key of the base relation
	\item view does not involve aggregates, group by or duplicate-elimination
\end{itemize}


\section{Indexes}

To add an index:

\t{CREATE INDEX <indexName> ON Table1(field1);}

to remove an index:

\t{DROP INDEX <indexName>}

\subsection*{Multicolumn Indexes}

\t{CREATE INDEX <indexName> on Table1(field1,field2);}

Multicolumn indexes first index on field1 and then on field2.

\newpage




\end{multicols}
\end{document}